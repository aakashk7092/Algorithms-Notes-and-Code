# Algorithms — Day 01 (Video 02)

## Topic  
**Priori Analysis vs Posteriori Testing**

This session focused on understanding the two major ways of evaluating an algorithm or a program:  
**Priori Analysis** and **Posteriori Testing**, and how they differ in purpose and approach.

---

## Priori Analysis

Priori analysis refers to evaluating an algorithm **before it is implemented**.

It is based on:
- The **algorithm itself**, not the program
- Being **independent of programming language**
- Being **independent of hardware**
- Measuring performance using:
  - **Time complexity**
  - **Space complexity**

This type of analysis helps in understanding how efficient an algorithm is **theoretically**, without executing any code.

In simple terms, priori analysis focuses on **logic and design efficiency**.

---

## Posteriori Testing

Posteriori testing refers to evaluating a solution **after it has been implemented** as a program.

It is based on:
- The **program**
- Being **dependent on the programming language**
- Being **dependent on hardware and operating system**
- Measuring performance using:
  - **Actual execution time**
  - **Memory usage (bytes)**

This type of testing helps in understanding how a program performs **in real-world conditions**.

In simple terms, posteriori testing focuses on **practical performance**.

---

## Key Differences

| Priori Analysis | Posteriori Testing |
|----------------|-------------------|
| Based on algorithm | Based on program |
| Language independent | Language dependent |
| Hardware independent | Hardware dependent |
| Uses time & space complexity | Uses execution time & memory |
| Theoretical evaluation | Practical evaluation |

---

## Key Learnings

- Priori analysis helps in choosing the **best algorithm** before coding.  
- Posteriori testing helps in validating the **actual performance** after coding.  
- Both are important:  
  - One ensures **efficient design**  
  - The other ensures **reliable execution**  

---

## Personal Understanding

> “A good solution is designed with priori analysis and perfected with posteriori testing.”

From now on, I will:
- First analyze algorithms using **time and space complexity**.  
- Then test programs using **real execution results**.  
This approach will help me write both **efficient** and **reliable** software.

---

## Learning Resource

Algorithms Playlist  
https://www.youtube.com/playlist?list=PLDN4rrl48XKpZkf03iYFl-O29szjTrs_O
